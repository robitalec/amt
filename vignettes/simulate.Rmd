---
title: "Simulate movement and space use with `amt`"
author: "Johannes Signer"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Simulate movement and space use with `amt`}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include=FALSE}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

## Dispersal kernel

The **dispersal kernel** is the basis for all simulations that are implemented in `amt`. The dispersal kernel consists of a habitat independent movement kernel, a habitat kernel and possible interactions between habitat and movement. The `amt` implementation combines the movement kernel and habitat kernel within the selection function of an *integrated Step Selection Function* (see Avgar et al. 2016, Signer et al. *in preparation*). The dispersal kernel needs to be updated at each time step to allow the animal to react to a spatially and temporally changing environment.

This formulation comes with the advantage that the model can be easily parameterized by fitting an iSSA to observed movement data. But it is also possible to build a dispersal kernel from scratch and use this for simulations.

### Dispersal kernel from scratch

#### Only movement (movement kernel)

```{r}
library(sf)
library(amt)
```

We start with the simplest dispersal kernel possible. This is a kernel that solely depends on the step-length distribution of the animal. We use a Gamma distribution here with parameters shape $k = 2$ and scale $\theta = 10$. 

```{r}
curve(dgamma(x, scale = 10, shape = 2), from = 0, to = 200, 
      ylab = "Density", xlab = "sl_")
```

Next, we have to translate the parameters of the step-length distribution to the selection function of the iSSA. There are function in `amt` to do this. The scale parameter is linked to the step length and and the shape parameter is linked to the log of the step length (see also Avgar et al. 2016 for details).

```{r}
library(amt)
devtools::load_all()
scale_to_sl(10)
shape_to_log_sl(2)
```

The last parameter that we need for calculating a dispersal kernel is a truncation distance. This is the maximum distance that is allowed by the dispersal kernel and we need this for computational reasons. An easy way to obtain this distance, is to just calculate the 95% or 99% quantile of the step-length distribution. Here we use the 99% quantile. 


```{r}
(max_dist <- qgamma(0.99, scale = 10, shape = 2))
```

With this we have all the important pieces together. The only information that is missing is a template for the landscape. We need this **even** if no spatial covariates are included because the dispersal kernel is sptially explicit on a landscape. The argument `spatial.covars` expects a raster stack (see also `?raster::stack`) with the resolution and with a (partially) overlapping extent of the dispersal kernel.

```{r}
# Create the extend and resolution of a raster
r <- raster(xmn = 0, xmx = 1e3, ymn = 0, ymx = 1e3, res = 1)
# Assign all cells a value of 1
r[] <- 1
# Create a raster stack
G <- raster::stack(r)
```

Now we can calculate a dispersal kernel using the function `dispersal_kernel()`.

```{r}
dk1 <- dispersal_kernel(
  # This is the selection function
  wx = ~ sl_ + log_sl_, 
  # We have to provide values for the coefficients 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1), 
  # The template for space
  spatial.covars = G, 
  # Give the center of the dispersal kernel
  start = c(500, 500), 
  # Maximum dispersal distance
  max.dist = 67,
  # Should a raster layer be returned?
  return.raster = TRUE)
```

```{r}
raster::plot(dk1)
```

Lets use the same dispersal kernel, but shift it towards the edge of the landscape.
This lead to truncation of the dispersal kernel. 


```{r}
dk2 <- dispersal_kernel(
  ~ sl_ + log_sl_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1), 
  spatial.covars = G, start = c(950, 980), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk2)
```


As a next step we can add directional persistence to the dispersal kernel using a von Mises distribution.
The von Mises distribution is a circular distribution that allows to model directions. 
We will start with a concentration parameter $\kappa = 1$ (0 would indicate a uniform distribution). 

```{r}
library(circular)
curve(dvonmises(x, mu = 0, kappa = 1), from = -pi, to = pi)
```

We can add an additional term to the selection function: the cosine of the turn angle, which introduces directionality. 
Hence, we have to translate the parameter $\kappa$ from the von Mises distribution into the a coefficient for the cosine of the turn angle (the function `kappa_to_cos_ta()`) does this.

```{r}
kappa_to_cos_ta(1)
```

Now we only have to adjust the arguments `wx` by adding `cos_ta_` and giving a coefficient value to for `cos_ta_`.
Everything else remains unchanged. 


```{r}
dk3 <- dispersal_kernel(
  wx = ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2), 
  spatial.covars = G, start = c(200, 200), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk3)
```

By default the direction of the dispersal kernel is 0 (north). 
This can be controlled with the argument `direction`. 
The direction should always be given in radiant. 

```{r}
dk5 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 1), 
  spatial.covars = G, start = c(200, 200), 
  return.raster = TRUE, max.dist = 67, direction = pi/2)
raster::plot(dk5)
```

#### Only habtiat (habitat kernel)

Let us now turn to a dispersal kernel without movement (i.e., it is purely goverend by habitat and a maximum distance). For this we simulate two landscapes. 

```{r}
G1 <- r
G1[, 1:500] <- 0

raster::plot(G1)

# Lets create again a raster stack
G1 <- raster::stack(G1)
names(G1) <- c("hab1")
```

Now we can simulate again a dispersal kernel independent of movement. 

```{r}
dk6 <- dispersal_kernel(
  ~ hab1_end,
  coefficients = c("hab1_end" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, direction = pi/2)
raster::plot(dk6)
```


We can add interaction between habitat covariates and non-spatial covariates (for example time of the day). 


```{r}
other <- tibble(day = 0:1)
dk6a <- dispersal_kernel(
  ~ hab1_end + hab1_end:day,
  coefficients = c("hab1_end" = 0.8, "hab1_end:day" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, temporal.covars = other[1, ])
raster::plot(dk6a)
```

The same dispersal kernel for the same position in space, but for the night. 
```{r}
dk6b <- dispersal_kernel(
  ~ hab1_end + hab1_end:day,
  coefficients = c("hab1_end" = 0.8, "hab1_end:day" = -0.8), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67, temporal.covars = other[2, ])
raster::plot(dk6b)

```

#### Movement and habitat

In a next step with the goal to make the dispersal kernel more realistic, we can add movement to the habitat selection (as illustrated before). 

```{r}
dk7 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, "hab1_end" = 1), 
  spatial.covars = G1, start = c(500, 500), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk7)
```
We can now even add an interaction between movement and habitat selection. For example the directional persistence now depends on the habitat at the center of the dispersal kernel. 

```{r}
dk8 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end + cos_ta_:hab1_start, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, 
                   "hab1_end" = 0.5, "cos_ta_:hab1_start" = -2), 
  spatial.covars = G1, start = c(400, 400), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk8)
```

Exactly the same dispersal kernel, but at a different start position.

```{r}
dk9 <- dispersal_kernel(
  ~ sl_ + log_sl_ + cos_ta_ + hab1_end + cos_ta_:hab1_start, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 2, 
                   "hab1_end" = 0.5, "cos_ta_:hab1_start" = -2), 
  spatial.covars = G1, start = c(600, 600), 
  return.raster = TRUE, max.dist = 67)
raster::plot(dk9)
```




#### How long does it take

```{r}
library(tidyverse)

res <- map(c(0.5, 1, 5, 10, 20, 50), ~ {
  lscp1 <- raster(xmn = 0, xmx = 1e3, ymn = 0, ymx = 1e3, res = .)
  lscp1[] <- 1
  lscp <- raster::stack(lscp1)
  names(lscp) <- "hab1"
  
  system.time(
    dk1 <- dispersal_kernel(
      ~ sl_ + log_sl_ + hab1_end, 
      coefficients = c(sl_ = -0.1, "log_sl_" = 1, "hab1_end" = 2), 
      spatial.covars = lscp, start = c(500, 500), 
      return.raster = TRUE, max.dist = 100)
  )
})

tibble(
  x = 1e4 / c(0.5, 1, 5, 10, 20, 50)^2, 
  y = map_dbl(res, "elapsed")
) %>% ggplot(aes(x, y)) + geom_point() +
  scale_x_continuous(trans = "log10") +
  labs(x = "No cells in dispersal kernel", y = "Time [s]")
```


## Simulate a trajectory

The next step is to simulate many dispersal kernels and sample a location where the animal is at the next time step from each dispersal kernel. 
The function `simulate_track()` is doing exactly this. 

```{r}
set.seed(123)
res1 <- simulate_track(
  ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 10),
  spatial.covars = G, start = c(100, 100), 
  n = 20, direction = pi/4) 

ggplot(res1, aes(x_, y_)) + geom_line() +
  coord_equal()
```

```{r}
set.seed(123)
res2 <- simulate_track_many(
  ~ sl_ + log_sl_ + cos_ta_, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 10),
  spatial.covars = G, start = c(100, 100), 
  n = 20, direction = pi/4, n.sim = 20) 

ggplot(res2, aes(x_, y_, group = rep_)) + geom_path(alpha = 0.3) +
  coord_equal()


```

We can add more realism here by adding attraction to an endpoint

```{r}
# Create an end point
G_dest <- G[[1]]
G_dest[] <- NA
G_dest[50, 950] <- 1
G_dest <- raster::stack(raster::distance(G_dest))
names(G_dest) <- "dest"
raster::plot(G_dest)
```

Now lets simulate 20 trajectories (all starting at the same point) with the same attraction to the endpoint. 

```{r}
set.seed(123)
res2 <- simulate_track_many(
  ~ sl_ + log_sl_ + cos_ta_ + dest_end, 
  coefficients = c("sl_" = -0.1, "log_sl_" = 1, "cos_ta_" = 10, 
                   "dest_end" = -0.5),
  spatial.covars = G_dest, start = c(100, 100), 
  n = 20, direction = pi/4, n.sim = 20) 

ggplot(res2, aes(x_, y_, group = rep_)) + geom_path(alpha = 0.3) +
  coord_equal()
```

We can also add a second resource (e.g., a patch that will be avoided). 

```{r, results="hide"}
G <- raster::raster(xmn = -500, xmx = 1500, ymn = -500, ymx = 1500, res = 1)
G_bar <- raster::rasterize(
  as_Spatial(st_as_sfc(list(st_buffer(st_point(c(500, 500)), dist = 250)))), 
  G, background = 0)

G_dest <- raster::rasterize(cbind(900, 900), G)
G_dest <- raster::distance(G_dest) / 1e3
names(G_dest) <- "dest"
G3 <- raster::stack(G_dest, G_bar)
names(G3) <- c("dest", "bar")

raster::plot(G3)
set.seed(123)
```

Now simulate 10 trajectories. 

```{r, results="hide"}
system.time({
  res2 <- simulate_track_many(
    ~ sl_ + log_sl_ + cos_ta_ + dest_end + bar_end, 
    coefficients = c("sl_" = -.1, "log_sl_" = 1, "cos_ta_" = 0, 
                     "dest_end" = -40, "bar_end" = -30),
    spatial.covars = G3, start = c(100, 100), 
    n = 100, direction = pi/4, n.sim = 10) 
})

raster::plot(G3[["bar"]])
points(100, 100, col = "red", pch = 20)
points(900, 900, col = "blue", pch = 20)
sapply(split(res2, res2$rep_), function(xx) 
  lines(xx$x_, xx$y_, col = adjustcolor("red", 0.3))
)
```


## Simulate a transient utilization distribution (TUD)

To possible options to move forward here: 

1. Repeat the previous step many time and just plot a map with individual trajectories, or
2. Count for every cell how often the animals passes through the cell. 

## Simulate a steady state utilization distribution (SSUD)

Some more work needs to be done here, do have a look at [Potts and SchlÃ¤gel 2020](https://besjournals.onlinelibrary.wiley.com/doi/full/10.1111/2041-210X.13406). 

## Real data

We will use a red deer from northern Germany to show how the simulation approach could be applied to real data. 

```{r}
data(deer)
data(sh_forest)
```


```{r}
forest <- sh_forest == 1
forest <- raster::stack(forest)
```

The first step is to fit a step selection function: 

```{r}
ssf_data <- deer %>%
  steps_by_burst() %>%
  random_steps(n = 15) %>%
  extract_covariates(forest) %>%
  mutate(cos_ta = cos(ta_),
         log_sl = log(sl_))

m2 <- ssf_data %>%
  fit_clogit(case_ ~ layer + cos_ta + sl_ + layer:sl_ + 
               strata(step_id_))

summary(m2)
```

Now we have to get the coefficient values for the simulations. This can be a bit tricky. For spatial covariates (e.g. `layer`) it is just the value of the coefficient from the fitted model (`m2`). For movement related covariates (e.g., `log_sl_`) we have to translate the tentative parameter to coefficients of the selection function. If we have included these covariates in the original model (for example `sl_`), we also have to adjust the estimates by adding the coeffient value to the tentative estimate.

```{r}
sim_coef <- c(
  "layer_end" = unname(coef(m2)["layer"]),
  "log_sl_" = unname(shape_to_log_sl(sl_distr_params(m2)$shape)), 
  "sl_" = unname(scale_to_sl(sl_distr_params(m2)$scale) + coef(m2)["sl_"]), 
  "layer_end:sl_" = unname(coef(m2)["layer:sl_"]), 
  "cos_ta_" = unname(kappa_to_cos_ta(ta_distr_params(m2)$kappa) + coef(m2)["cos_ta"]))
```

Now it is possible to calculate the dispersal kernel at any position: 

```{r, eval = TRUE}
# from position 2
dk_p2 <- dispersal_kernel(
  ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
  coefficients = sim_coef, 
  spatial.covars = forest, start = c(deer$x_[2], deer$y_[2]), 
  return.raster = TRUE, 
  max.dist = ceiling(qgamma(0.99, shape = sl_distr_params(m2)$shape, 
                    scale = sl_distr_params(m2)$scale)))
raster::plot(dk_p2)
```

Or simulate a trajectory

```{r, eval = FALSE}
trk1 <- simulate_track(
  ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
  coefficients = sim_coef, 
  spatial.covars = forest, start = c(deer$x_[2], deer$y_[2]), 
  max.dist = ceiling(qgamma(0.95, shape = sl_distr_params(m2)$shape, 
                            scale = sl_distr_params(m2)$scale)), 
  n = 20
)

#' Plot the track
trk1 %>% 
  ggplot(aes(x_, y_)) + geom_path() + 
  geom_point(x = deer$x_[2], y = deer$y_[2], col = "red") +
  coord_equal()
)
```

It is probably more interesting to repeat this step many times (e.g., 20 times).

```{r}
trks1 <- simulate_track_many(
  ~ layer_end + cos_ta_ + sl_ + log_sl_ + layer_end:sl_, 
  coefficients = sim_coef, 
  direction = pi/2,
  spatial.covars = forest, start = c(deer$x_[2], deer$y_[2]), 
  max.dist = ceiling(qgamma(0.95, shape = sl_distr_params(m2)$shape, 
                            scale = sl_distr_params(m2)$scale)), 
  n = 20, n.sim = 20
)

# Create an other plot
trks1 %>% bind_rows() %>% 
  ggplot(aes(x_, y_, group = rep_)) + geom_path(alpha = 0.1) +
  geom_point(x = deer$x_[2], y = deer$y_[2], col = "red") +
  coord_equal()
```


## Session

```{r}
sessioninfo::session_info()
```


